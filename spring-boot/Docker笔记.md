##Docker笔记
	install docker：
	linux：Centos下安装，yum install docker，然后启动docker：service docker start
	windows：安装 Docker Toolbox，一步一步默认安装即可，安装完成运行Docker quickstart即可，如果启动失败可能是boot2docker启动器下不来，需要手动下载放到C盘目录下即可。默认启动一个192.168.0.99.100的镜像服务器。

##镜像Build
	Dockerfile文件：
    Command指令：
    FROM
	MAINTAINER
	RUN
	CMD
	EXPOSE
	ENV
	ADD
	COPY
	ENTRYPOINT
	VOLUME
	USER
	WORKDIR
	ONBUILD
    详解：
    1.From ：指定构建镜像的基础镜像，可以出现多个，如果本地没有镜像，则将从远程公共库pull下来
    	FROM <image>
    2.MAINTAINER ：指定创建镜像的用户
    	MAINTAINER <name>
    3.RUN  有两种使用方式，每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像
		RUN
		RUN "executable", "param1", "param2"
        exec 方式：解析为一个 JSON 数组，所以必须使用双引号而不是单引号exec 方式不会调用一个命令 shell，所以也就不会继承相应的变量
        RUN [ "sh", "-c", "echo", "$HOME" ]
    4.CMD：三种使用方式，CMD指定在 Dockerfile 中只能使用一次。注意：CMD会在启动容器的时候执行，build 时不执行，而RUN只是在构建镜像的时候执行，后续镜像构建完成之后，启动容器就与RUN无关了
    	CMD "executable","param1","param2"
		CMD "param1","param2"
		CMD command param1 param2 (shell form)
    5.EXPOSE ： Docker 服务端容器对外映射的本地端口，需要在 docker run 的时候使用-p或者-P选项生效
    6.ENV ： 指定环境变量，会被后续RUN指令使用，并在容器运行时保留
    	ENV <key> <value>       # 只能设置一个变量
		ENV <key>=<value> ...   # 允许一次设置多个变量
    7.ADD ： ADD复制本地主机文件、目录或者远程文件 URLS 从 并且添加到容器指定路径中，支持正则模糊匹配
    	路径必须是 Dockerfile 所在路径的相对路径，如果是一个目录，只会复制目录下的内容，而目录本身则不会被复制
    	ADD <src>... <dest>
    8.COPY ： COPY复制新文件或者目录从 并且添加到容器指定路径中 。用法同ADD，唯一的不同是不能指定远程文件 URLS
    	COPY <src>... <dest>
    9.ENTRYPOINT ： 配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖，而CMD是可以被覆盖的。如果需要覆盖，则可以使用docker run --entrypoint选项，每个dockfile中只能有一个
    	ENTRYPOINT "executable", "param1", "param2"
		ENTRYPOINT command param1 param2 (shell form)
    10.VOLUME ： 创建一个可以从本地主机或其他容器挂载的挂载点
    	VOLUME ["/data"]
    11.USER ： 指定运行容器时的用户名或 UID，后续的RUN、CMD、ENTRYPOINT也会使用指定用户
    	USER daemon
    12.WORKDIR ： 为后续的RUN、CMD、ENTRYPOINT指令配置工作目录可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径
    	WORKDIR /path/to/workdir
    13.ONBUILD ： 配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令
    	ONBUILD [INSTRUCTION]
        example：
        		Dockerfile 使用如下的内容创建了镜像 image-A：
				[...]
				ONBUILD ADD . /app/src
				ONBUILD RUN /usr/local/bin/python-build --dir /app/src
				[...]
				如果基于 image-A 创建新的镜像时，新的 Dockerfile 中使用 FROM image-A 指定基础镜像时，会自动执行 ONBUILD 指令内容，等价于在后面添加了两条指令。
				# Automatically run the following
				ADD . /app/src
				RUN /usr/local/bin/python-build --dir /app/src
				使用ONBUILD指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild

##Dockerfile Examples
	# Nginx
	#
	# VERSION               0.0.1

	FROM      ubuntu
	MAINTAINER Victor Vieux <victor@docker.com>

	RUN apt-get update && apt-get install -y inotify-tools nginx apache2 openssh-server

	# Firefox over VNC
	#
	# VERSION               0.3

	FROM ubuntu

	# Install vnc, xvfb in order to create a 'fake' display and firefox
	RUN apt-get update && apt-get install -y x11vnc xvfb firefox
	RUN mkdir ~/.vnc
	# Setup a password
	RUN x11vnc -storepasswd 1234 ~/.vnc/passwd
	# Autostart firefox (might not be the best way, but it does the trick)
	RUN bash -c 'echo "firefox" >> /.bashrc'

	EXPOSE 5900
	CMD    ["x11vnc", "-forever", "-usepw", "-create"]

	# Multiple images example
	#
	# VERSION               0.1

	FROM ubuntu
	RUN echo foo > bar
	# Will output something like ===> 907ad6c2736f

	FROM ubuntu
	RUN echo moo > oink
	# Will output something like ===> 695d7793cbe4

	# You᾿ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with
	# /oink.

##docker build 构建镜像
	$ docker build --help

	Usage: docker build [OPTIONS] PATH | URL | -

	Build a new image from the source code at PATH

	--force-rm=false     Always remove intermediate containers, even after unsuccessful builds # 移除过渡容器，即使构建失败
    --no-cache=false     Do not use cache when building the image                              # 不实用 cache
    -q, --quiet=false    Suppress the verbose output generated by the containers
    --rm=true            Remove intermediate containers after a successful build               # 构建成功后移除过渡层容器
    -t, --tag=""         Repository name (and optionally a tag) to be applied to the resulting image in case of success

##dockerfile 最佳实践
	1.使用.dockerignore文件
		为了在docker build过程中更快上传和更加高效，应该使用一个.dockerignore文件用来排除构建镜像时不需要的文件或目录。例如,除非.Git在构建过程中需要用到，否则你应该将它添加到.dockerignore文件中，这样可以节省很多时间。
	2.  避免安装不必要的软件包
		为了降低复杂性、依赖性、文件大小以及构建时间，应该避免安装额外的或不必要的包。例如，不需要在一个数据库镜像中安装一个文本编辑器
    3.多行参数排序
    	如果可能，通过字母顺序来排序，这样可以避免安装包的重复并且更容易更新列表，另外可读性也会更强，添加一个空行使用\换行:
		RUN apt-get update && apt-get install -y \
		bzr \
	    cvs \
		git \
		mercurial \
		subversion

##Dockerfile 指令
	FROM: 只要可能就使用官方镜像库作为基础镜像
    RUN: 为保持可读性、方便理解、可维护性，把长或者复杂的RUN语句使用\分隔符分成多行
	不建议RUN apt-get update独立成行，否则如果后续包有更新，那么也不会再执行更新
	避免使用RUN apt-get upgrade或者dist-upgrade，很多必要的包在一个非privileged权限的容器里是无法升级的。如果知道某个包更新，使用apt-get install -y xxx
	标准写法
	RUN apt-get update && apt-get install -y package-bar package-foo
	CMD: 推荐使用CMD [“executable”, “param1”, “param2”…]这种格式，CMD [“param”, “param”]则配合ENTRYPOINT使用
	EXPOSE: Dockerfile 指定要公开的端口，使用docker run时指定映射到宿主机的端口即可
	ENV: 为了使新的软件更容易运行，可以使用ENV更新PATH变量。如ENV PATH /usr/local/nginx/bin:$PATH确保CMD ["nginx"]即可运行
	ENV也可以这样定义变量：
    	ENV PG_MAJOR 9.3
		ENV PG_VERSION 9.3.4
		RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress && …
		ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH
    ADD or COPY:ADD比COPY多一些特性「tar 文件自动解包和支持远程 URL」，不推荐添加远程 URL
    不推荐这种方式：
	    ADD http://example.com/big.tar.xz /usr/src/things/
		RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things
		RUN make -C /usr/src/things all
    推荐使用 curl 或者 wget 替换，使用如下方式:
    	RUN mkdir -p /usr/src/things \
	    && curl -SL http://example.com/big.tar.gz \
	    | tar -xJC /usr/src/things \
	    && make -C /usr/src/things all
    如果不需要添加 tar 文件，推荐使用COPY